# 一、Spring Cloud 微服务项目架构剖析——daijia

## 1. daijia-parent（父项目）
- **作用**：这是整个项目的父级 Maven 项目，所有子模块（如 `web`、`service` 等）都会继承这个父项目的依赖和配置。这有助于**统一管理项目中所有模块的依赖版本、插件配置，并简化各个子模块的配置。**
- **pom.xml**：`pom.xml` 文件中会**定义全局的依赖、插件配置**等，同时还会定义各个子模块。这使得所有子模块可以共享相同的配置，保持模块间的一致性。

---

## 2. common（公共模块）
- **作用**：用于存放项目中所有模块可能都会使用的**公共类和工具类**。它的作用是**减少重复代码，提升代码的复用性和一致性。**任何模块都可以引入 `common` 模块，从而使用里面的通用功能。
- **典型内容**：
  - **工具类**：如日期处理工具、字符串工具等。
  - **异常处理**：**全局异常处理类**，封装了统一的异常处理逻辑。
  - **统一响应类**：封装了 API 返回的结果对象，**如 `Result` 类，用于封装响应状态码、消息和数据。**

---

## 3. model（数据模型模块）
- **作用**：这是用于定义整个项目中使用的数据模型的模块。该模块的作用是**将数据对象进行标准化，以便在服务之间进行数据传输或持久化时保持一致。**
- **典型内容**：
  - **实体类（Entities）**：**对应数据库表的对象**，用于持久化数据。
  - **数据传输对象（DTO）**：用于**服务之间的数据传输**，通常包含 API 接口的数据字段。
  - **视图对象（VO）**：用于**前端展示的数据模型**，通常是 API 响应的数据格式。

---

## 4. server-gateway（网关服务模块）
- **作用**：作为整个微服务架构的 API 网关，**负责处理所有外部请求的统一入口**。它会将请求路由到具体的微服务，并可以实现一些预处理、后处理逻辑，如鉴权、限流、负载均衡等。**API 网关有效地将内部服务与外部隔离，使得微服务系统更安全和可控。**
- **典型技术**：Spring Cloud Gateway 或 Zuul
- **典型功能**：
  - **路由**：将**外部请求分发**到具体的微服务（如 `service`）。
  - **过滤器**：可以执行请求的预处理和后处理逻辑，例如鉴权、日志记录、限流等。
  - **负载均衡**：支持**多个服务实例之间的负载均衡。**

---

## 5. service（业务服务模块）
- **作用**：这是核心业务处理模块，**每个 `service` 模块代表一个独立的业务微服务**。每微服务负责特定的业务功能，如用户管理、订单处理等。业务逻辑、数据库交互以及和其他微服务的交互都在这个模块中实现。
- **典型内容**：
  - **业务逻辑**：具体的业务逻辑处理类和方法。
  - **控制器（Controller）**：暴露 API 接口，接收外部请求并调用业务逻辑层。
  - **数据访问层（DAO/Repository）**：与数据库交互的类，使用 JPA 或 MyBatis 访问数据库。
  - **服务层（Service）**：封装业务逻辑，并调用 DAO 层进行数据操作。

---

## 6. service-client（服务调用客户端模块）
- **作用**：这个模块是**微服务之间通信的核心部分**，它封装了与其他微服务的远程调用逻辑。通过 `service-client`，微服务之间可以通过 **HTTP 调用**进行数据交换。通常使用 **OpenFeign 或 RestTemplate** 进行服务之间的远程调用，并且可以加入负载均衡、熔断等机制，保证服务调用的稳定性。
- **典型技术**：OpenFeign、RestTemplate
- **典型功能**：
  - **远程调用**：使用 **OpenFeign 进行声明式的 HTTP 远程调用**，简化了接口调用的复杂性。
  - **负载均衡**：通过 Ribbon 或 Spring Cloud LoadBalancer 实现客户端负载均衡。
  - **熔断器**：结合 Hystrix 或 Resilience4j 实现熔断机制，保证当某个微服务不可用时，系统可以快速返回默认响应，防止故障蔓延。

---

## 7. web（Web 前端模块）
- **作用**：该模块负责**处理来自前端的 Web 请求，**充当用户接口层。**它通常会通过 API 调用后端服务（通过 `service-client` 模块调用远程服务），并将返回的数据传递给前端。**`web` 模块中的控制器类会处理具体的 HTTP 请求，调用业务逻辑，并返回相应的结果给用户。
- **典型功能**：
  - **API 控制器**：处理前端的 HTTP 请求，并调用业务服务。
  - **服务调用**：通过 `service-client` 调用后端业务服务（`service` 模块）。
  - **响应处理**：将业务逻辑处理后的结果以统一格式返回给前端。

---

## 8. 资料（Documentation）
- **作用**：存放项目相关的文档文件。可能包含项目的设计文档、接口文档、开发规范、架构图等。
- **内容**：
  - 项目设计文档
  - API 接口文档
  - 系统架构文档

---

## 项目模块的联系与典型工作流程

1. **用户请求流程**：
   - 用户通过浏览器或移动端发出请求，首先通过 **server-gateway（API 网关模块）**。
   - API 网关模块会将请求路由到 **web 模块** 中的 API 控制器。

2. **业务处理流程**：
   - **web 模块** 接收请求后，通过 `service-client` 远程调用其他业务微服务（`service` 模块）。
   - **service-client** 封装了远程调用的逻辑，可以使用 OpenFeign 或 RestTemplate 进行远程服务的通信。

3. **返回结果**：
   - **service 模块** 处理具体的业务逻辑后，返回数据给 **web 模块**。
   - **web 模块** 将数据以 API 响应的形式返回给用户。

4. **公共模块的使用**：
   - 所有模块都可以使用 **common 模块** 中的工具类、全局异常处理和其他公共逻辑。
   - 数据模型由 **model 模块** 进行定义，并在所有服务间共享。

---

# 微服务架构中的关键问题剖析

## 1. 为什么要先经过 Gateway 模块，而不是直接到 Web 模块？

### API 网关的作用
- **集中管理请求**：API 网关是整个微服务架构的**统一入口**，所有外部的请求都需要先经过 API 网关。网关会根据请求的路径或其他条件将请求路由到对应的微服务。它主要有以下功能：
  - **请求路由**：根据请求路径，将请求转发到具体的微服务，如 Web 模块或其他业务模块。
  - **安全性**：API 网关可以处理**认证和授权**，例如通过 JWT Token 进行身份验证。这样每个微服务不必各自实现复杂的安全机制，只需专注于业务逻辑。
  - **负载均衡**：API 网关可以对请求进行**负载均衡**，将流量均匀分配到不同的服务实例中，避免某些实例的过载。
  - **统一入口**：API 网关为所有微服务提供了一个统一的外部访问入口，客户端只需要知道网关的地址，不必了解具体的微服务位置。
  - **跨域处理**：如果前端与后端进行跨域请求，API 网关可以统一处理跨域请求，简化微服务中的跨域管理。

### 为什么不能直接跳过网关？
- **缺少统一管理**：如果每个外部请求都直接访问具体的微服务（如 Web 模块或业务模块），系统将失去统一管理请求、安全控制和流量管理的能力。这会导致安全隐患和管理的复杂性增加。
- **负载均衡问题**：直接访问服务可能会导致某些服务实例过载，无法有效分配请求压力。网关的负载均衡功能可以确保请求均衡分布，提高系统的稳定性。

### API 网关的关键功能：
- **路由**：将请求分发到后端的具体服务。
- **鉴权与安全**：处理身份认证和权限校验。
- **负载均衡**：均匀分配请求。
- **流量控制**：限流、防止请求泛滥。
- **跨域支持**：统一处理跨域请求。

---

## 2. 为什么要加 Web 模块，业务模块里面的 Controller 层不能直接返回数据给前端？

### Web 模块的作用
- **分层架构的设计**：Web 模块通常用于处理用户接口请求，是整个系统的“表现层”。虽然业务模块中的 `Controller` 层也能直接处理外部请求，但将 Web 层和业务层分开有以下好处：
  - **职责分离**：Web 模块专注于处理**前端请求和展示逻辑**，而业务模块专注于处理**核心业务逻辑**。这种设计可以让系统的关注点更加明确，便于维护和扩展。
  - **适配前端需求**：Web 模块可以对前端的请求和返回数据格式进行定制，帮助不同类型的客户端（Web、移动端）处理不同的数据需求。例如，Web 模块可以将后端返回的数据封装成符合前端需求的格式，并对接口进行适配。
  - **安全和前端适配逻辑**：Web 模块还可以负责一些前端适配逻辑（如分页、过滤、数据格式转换），减少对业务模块的侵入。
  - **可扩展性**：Web 模块的独立性使得未来如果需要更改前端需求或增加更多接口逻辑，可以仅修改 Web 模块而不需要改变核心的业务模块，增强系统的扩展性和灵活性。

### 为什么业务模块不直接返回数据给前端？
- **避免职责混乱**：业务模块中的 `Controller` 层主要用于处理核心业务逻辑，如果让它同时处理前端请求、适配前端需求，这会导致职责混乱，降低代码的可读性和可维护性。
- **前后端分离的设计理念**：前后端分离是现代 Web 开发的趋势，Web 模块可以作为 API 层来处理前端请求，而业务模块仅专注于业务逻辑。这样设计有助于实现系统的高内聚低耦合。

### Web 模块的关键功能：
- **处理外部请求**：处理用户的 HTTP 请求。
- **数据格式转换**：将后端的数据处理成前端需要的格式（如 JSON）。
- **前端适配**：根据不同客户端需求，定制接口响应。

---

## 3. 为什么 Web 模块要通过 service-client 使用业务逻辑模块？什么是 OpenFeign 和 RestTemplate？

### 为什么 Web 模块要通过 `service-client` 访问业务模块？
- **服务解耦**：在微服务架构中，业务模块和 Web 模块通常是**独立的微服务**。它们之间的通信通常通过 **HTTP 远程调用**进行，而不是直接调用类或方法。**`service-client` 模块封装了这些远程调用的逻辑**，使 Web 模块不需要知道业务模块的实现细节，只**需要调用服务的接口。**这种方式有助于服务解耦，便于系统扩展和维护。
  - **松耦合架构**：通过 `service-client` 进行远程调用，Web 模块不需要直接依赖业务模块的实现，可以专注于前端逻辑。
  - **高扩展性**：当业务模块需要更新或扩展时，只需要修改 `service-client` 的调用逻辑，而不必修改 Web 模块的代码。
  - **网络通信的封装**：`service-client` **可以封装网络通信的细节，如服务发现、负载均衡等。**

### 什么是 OpenFeign 和 RestTemplate？
- **OpenFeign**：是 Spring Cloud 中的一个**声明式 HTTP 客户端**，它使得开发者可以用类似调用本地方法的方式**进行远程服务调用，而不需要手动编写 HTTP 请求。**
  
  - **简单声明式调用**：通过**定义接口并使用注解，Feign 可以自动处理 HTTP 请求和响应**，开发者不需要关心底层细节。
  - **负载均衡支持**：Feign 可以集成 Ribbon，实现客户端的负载均衡。
  - **熔断器支持**：与 Hystrix 或 Resilience4j 结合，可以实现远程调用失败时的熔断机制。
  - **示例**：
    ```java
    @FeignClient("user-service")
    public interface UserServiceClient {
        @GetMapping("/api/users/{id}")
        UserDTO getUserById(@PathVariable("id") Long id);
    }
    ```
  
- **RestTemplate**：是 Spring 提供的用于**同步 HTTP 请求**的工具类，它支持基本的 HTTP 请求操作（如 GET、POST、PUT、DELETE）。相对于 Feign，RestTemplate 更底层，需要手动编写 HTTP 请求和处理响应。
  - **灵活性高**：可以自定义请求和响应，适合复杂的场景。
  - **手动处理请求**：开发者需要手动构造请求 URL、请求体等，适合自定义需求较高的场景。
  - **示例**：
    ```java
    RestTemplate restTemplate = new RestTemplate();
    ResponseEntity<UserDTO> response = restTemplate.getForEntity("http://user-service/api/users/{id}", UserDTO.class, id);
    ```

### OpenFeign 与 RestTemplate 的选择
- **OpenFeign** 更适合场景：对于大多数**简单的远程调用**场景，使用 OpenFeign 更加简洁和易维护，因为它提供了声明式的调用方式，减少了手动构造 HTTP 请求的工作。（Rest API用这个）
- **RestTemplate** 更适合场景：当需要更多的自定义控制（如定制 HTTP 请求头、处理复杂的请求/响应结构）时，**RestTemplate** 可能更合适，因为它提供了更灵活的控制。

### `service-client` 的作用：
- **封装远程调用**：通过 OpenFeign 或 RestTemplate 封装对其他微服务的调用逻辑，简化 Web 模块的工作。
- **负载均衡和熔断支持**：提供客户端负载均衡和熔断机制，提升系统的稳定性。

---

## 总结

1. **为什么要经过 Gateway（就是API网关） 模块？**
   - API 网关提供了**请求路由、负载均衡、安全认证、流量控制**等功能，是微服务架构中的统一入口。跳过网关将导致请求管理的复杂性增加，并且无法集中处理安全和负载均衡等问题。
2. **为什么要加 Web 模块？**
   - Web 模块专注于处理外部请求并适配前端需求，业务模块专注于核心业务逻辑。将二者分离有助于系统的职责分离，提高可维护性和扩展性。**微服务架构关键：解耦！！！**
3. **为什么 Web 模块要通过 `service-client` 使用业务模块？**
   - 在微服务架构中，业务模块与 Web 模块是独立的服务，`service-client` 封装了远程服务调用逻辑，使微服务之间的调用更加简单！！！

------



# 项目模块拆分——从前到后

## 1.项目概述（项目介绍、框架图）

### 1.1技术架构

![](.\assets\image-20240620203904041.png)

### 1.2 技术概述

- **SpringBoot**：简化Spring应用的初始搭建以及开发过程
- **SpringCloud**：基于Spring Boot实现的云原生应用开发工具，SpringCloud使用的技术：（Spring Cloud Gateway、Spring Cloud Task和Spring Cloud Feign等）
- **SpringBoot+SpringCloudAlibaba(Nacos，Sentinel) + OpenFeign + Gateway**
- MyBatis-Plus：持久层框架，也依赖mybatis
- Redis：内存做缓存
- Redisson：基于redis的Java驻内存数据网格 - 框架；操作redis的框架
- MongoDB: 分布式文件存储的数据库
- RabbitMQ：消息中间件；大型分布式项目是标配；分布式事务最终一致性
- Seata：分布式事务
- Drools：规则引擎，计算预估费用、取消费用等等
- GEO：GPS分区定位计算
- ThreadPoolExecutor+CompletableFuture：异步编排，线程池来实现异步操作，提高效率
- XXL-JOB: 分布式定时任务调用中心
- Knife4J/YAPI：Api接口文档工具
- MinIO（私有化对象存储集群）：分布式文件存储 类似于OSS（公有）
- 微信支付：微信支付与微信分账
- MySQL：关系型数据库 {shardingSphere-jdbc 进行读写分离; 分库，分表}
- Lombok: 实体类的中get/set 生成的jar包
- Natapp：内网穿透
- Docker：容器化技术;  生产环境Redis（运维人员）；快速搭建环境Docker run

### 1.3 业务流程

![](.\assets\image-20240620210153207.png)

![](.\assets\image-20240620210245930.png)

![](.\assets\image-20240620210300386.png)

## 2.乘客端登录

### 2.1微信小程序登录接口开发

![](.\assets\image-20240506112804142.png)

![](.\assets\image-20241024224319373.png)

### 2.2获取登录用户信息接口开发

![](.\assets\image-20240507094816943.png)

### 2.3 登录校验

-- 判断请求头里面是否包含token字符串

-- 根据token查询redis

-- 原始方式：在需要判断登录的controller进行上面判断（token和redis）

-- 如果使用原始方式，功能肯定可以实现的，但是造成有大量重复代码

-- 对这样方式进行优化

![](.\assets\image-20240507135812851.png)

![](.\assets\image-20240507140803142.png)

![](.\assets\image-20240507140821251.png)

创建自定义注解要加上元注解（**元注解就是对注解的说明限制**）；@interface是注解的意思，不是接口！！！！



### 2.4 乘客端登录：获取微信手机号

**说明：获取手机号必须是企业级微信公众号，个人版获取不到。**

如果登录发现没有绑定手机号，那么返回的那个实体类手机号字段为fasle，**触发前端页面显示要绑定手机号（此时前端会请求一个资源路径）** 用户同意一键绑定手机号，会获得动态令牌code，通过code获取手机号。**注意：每个code只能使用一次，code的有效期为5min。**

重点：**用户点击一键绑定会调用接口自动获取code，并把code和用户id以json文件形式发到后端！！！**

![](.\assets\image-20240507214147107.png)



## 3.司机端登录与认证

![](.\assets\image-20240510135339274.png)

### 3.1司机端微信小程序登录

![](.\assets\31.png)

### 3.2获取登录司机信息

![](.\assets\32.png)

### 3.3腾讯云对象存储上传接口

![](.\assets\33.png)

path是上传到bucket的路径

### 3.4腾讯云身份证、驾驶证认证接口

![](.\assets\34.png)

### 3.5获取司机的认证信息

* 司机进行操作首先进行登录，登录成功之后，进行认证，跳转到认证页面完成认证
* **查看认证信息**，进入到认证页面时候，回显证件信  息

(**前端进行了处理，接口调用完成后，driveinfo有了更新就会马上同步回显**)



### 3.6修改司机认证信息



**认证状态：**

​	 0:未认证 【刚注册完为未认证状态】

​	1：审核中 【提交了认证信息后变为审核中】

​	2：认证通过 【后台审核通过】

​	-1：认证未通过【后台审核不通过】

* **第一次登录时候，完成用户注册，注册时候，当前认证状态值是0（未认证）**
* **上传认证信息（填写认证资料）之后，进行提交，提交之后，当前认证状态值1（审核中）**
* **司机端提交审核资料之后，后台管理员对提交资料进行审核，审核通过，认证状态值2，审核没有通过，认证状态值-1**



### **阶段总结思维图：**

![1730430396883_d](.\assets\1730430396883_d.jpg)

## 4.理清项目架构文件级别

标准目录结构

```
your-project/项目或模块
 ├── src/
 │   ├── main/
 │   │   ├── java/                # 源代码根目录
 │   │   │   └── com/
 │   │   │       └── example/
 │   │   │           └── yourapp/
 │   │   │               └── YourApplication.java
 │   │   ├── resources/           # 资源根目录
 │   │   │   ├── application.properties  # 配置文件
 │   │   │   └── static/          # 静态资源（如HTML、CSS、JS）
 │   │   └── META-INF/            # 元信息（如服务描述）
 │   └── test/
 │       ├── java/                # 测试源代码根目录
 │       │   └── com/
 │       │       └── example/
 │       │           └── yourapp/
 │       │               └── YourApplicationTests.java
 │       └── resources/           # 测试资源根目录
 │           └── application-test.properties  # 测试配置文件
 └── pom.xml                     # Maven配置文件（或build.gradle）

```

**重点：**

1.明确结构：项目/模块——src+pom.xml——src下分main和test——下面的架构都一样:

java和resources并列，**测试的没有resources**。main下的resources放yml配置文件，static放网页资源。两个的java下面都是公司域名反写（这里要一样的名字），**最后就是启动类和测试类所处的包级别要一样！！！！**

2.**明确关键词：**

**源代码根目录和测试源代码根目录都是java的，资源根目录是resources，**

3.有一个概念明确，很多时候会说**同包下，会发现有些模块的多级包都是一样的**！！！同一模块的main和test下的多级包就会是一样，很简单：**测试的时候依赖注入，扫描当前包及其子报下的bean。在test下面其实是没有配的，但就是同一包名有联动的效果**



## 5.预估订单数据

### 5.1 查找乘客当前订单

* 如果乘客有代驾订单正在进行中，这个时候乘客不能再次下单了，只有等当前订单完成之后，才可以下单
* 这个功能因为订单相关，**后续再进行处理**，目前为了后续测试，临时跳过去，假设当前乘客没有订单

### 5.2预估驾驶线路——只写业务微服务模块和远程调用接口

1. 开通腾讯位置服务——获取key

2. 修改Nacos配置文件，修改腾讯位置服务key

3. 接口编写：**关注进来什么数据，出去什么数据**

   进入的数据：前端提供

   ![image-20241107152358299](.\assets\image-20241107152358299.png)

​	出去的数据：

![image-20241107152436510](.\assets\image-20241107152436510.png)

### 5.3预估订单数据-预估订单金额

1. Drools规则引擎（可看单独课件复习）

2. 费用规则

   **代驾费用=里程费 + 等候费 + 远途费**

   ![image-20241107153059403](.\assets\image-20241107153059403.png)

![image-20241107153136087](.\assets\image-20241107153136087.png)

![image-20241107153153321](.\assets\image-20241107153153321.png)

 3.接口编写：**进来什么对象，出去什么**

​	进来：

![image-20241107153327767](.\assets\image-20241107153327767.png)

​	出去：

![image-20241107154251254](.\assets\image-20241107154251254.png)

![image-20241107154301567](.\assets\image-20241107154301567.png)

### **5.4 综合调用驾驶路线和订单金额接口——返回订单数据**

1. 先理清楚框架思路：前端乘客选择出发地和结束地，**会发送给后端两个地点的经纬度。**
2. 后端的web-customer模块接收在service层处理，调用驾驶路线接口和费用计算接口，这需要传入对象。
3. **对于驾驶路线：**参数都一样，直接copyproperties。，调用接口得到返回的result对象里面装的DrivingLineVo
4. **对于计算驾驶费用：**它需要驾驶总路程+等候时间+开始驾驶时间。**路程从返回的驾驶路线接口获得（这个返回的是最佳路线），等候时间先给的0，开始时间先new一个date对象**
5. 返回的两个对象封装进入一个对象ExpectOrderVo返回给前端

总结：**用户选择出发地和结束地址，返回订单数据（含两个接口调用）**

## 6.乘客下单

### 6.1——保存订单信息

![image-20241107165027053](.\assets\image-20241107165027053.png)

**参数明确**

前端传入的参数是：

![image-20241107165148058](C:\Users\14586\AppData\Roaming\Typora\typora-user-images\image-20241107165148058.png)

**会在web-customer的service层重新计算驾驶路线和费用，封装进去，确保安全性**。在后面的业务微服务模块的service中使用UUID生产订单号（不是订单id）和更新订单状态。

返回：回来的是订单的id：**orderid**

### 6.2乘客下单2——查询订单状态接口（查询乘客端的订单状态）

乘客端和司机端可以根据orderid去数据库查询此时乘客的状态：

1.等待接单；2.已经接单

### **重点：阶段性总结以及下一步做什么**

![image-20241107164749733](.\assets\image-20241107164749733.png)

![image-20241107164725706](.\assets\image-20241107164725706.png)

### **补充1：所有表的id主键和order_id、drive_id等是不一样概念**

表的主键id代表来了数据就自动增加，drive_id等等应该是前端发过来的唯一标识。

项目代码中用了很多selectone，而不是selectbyid。

**selectbyid是选择主键id,这个selectone是用wrapper对象，方法引用driveid**

### 补充2：swagger/knife4j交互查看接口文档

一般单体项目启动**就一个端口号8080**，所以**直接localhost:8080/doc.html**

微服务项目解耦了，专注于功能拆分，聚合。不同的微服务模块启动有不同的端口号。localhost：xxxx/doc.html

**输入xxxx进入对应的这个微服务模块设计的接口组成的文档**（Tag控制器类上面区分大类，控制层里面的函数上面operation指明这个请求是什么操作。scheme注明字段是干什么的。）

### 补充3：@SneakyThrows

`@SneakyThrows` 是 **Lombok 库**提供的一个注解，用于在**编译时（写代码时）自动处理受检异常**（即必须捕获或声明的异常），从而简化代码。

`@SneakyThrows` 允许你在不使用 `try-catch` 块和 `throws` 关键字的情况下抛出受检异常。**编译器会自动添加抛出异常的代码，所以可以简化代码的编写，减少代码量。**



### 6.3乘客下单3——搜索附近可以接单司机（实时更新司机的位置信息）

**司机开启接单服务后，司机端小程序就会实时上传经纬度信息到redis的GEO，关闭接单服务我们就要清空GEO数据，当前就一并把更新与删除司机位置信息给写了，删除不需要提供web接口，其他service服务方法调用。**

重点：**前端会做定时器处理，定时发送更新请求**

### 6.4乘客下单4——搜索附近可以接单司机（获取司机个性化设置消息）

司机的个性化设置信息在一开始就保存了，这里做的是获取这个表中的信息（**司机是否接单**），把业务微服务做好，远程调用做好，在web微服务层调用（**当实时更新司机的位置信息时，需要判断司机个性化设置表中的接单状态字段是否为1**，为1接单状态才可以继续远程调用）

### 6.5乘客下单5——搜索附近可以接单的司机（redis的geo功能查询返回满足条件的司机list）

这里需要说明下业务的代码逻辑，todo可用gpt.

1.接收**搜索参数**（经纬度、订单距离）

2.定义**搜索范围**（5 公里半径）

3.**查询 Redis GEO 数据**

4.筛选司机：是否符合订单距离限制、是否符合接单距离限制

5.封装合格司机信息

6.返回符合条件的司机列表

### **重点思路理清：谁调用哪个接口**

6.1、6.2、6.5这三个是乘客端的接口发起（**保存订单信息、查询乘客端订单状态暂时没用到、搜索附近可以接单的司机信息**）

6.3、6.4是司机端的接口发起（**实时更新司机位置信息、获取司机个性化设置**）

**双端有配合的！！！**



### 6.6任务调度——思路框架

![image-20241112162236214](.\assets\image-20241112162236214.png)

**乘客下单了，然后启动一个任务调度，每隔1分钟执行一次搜索附近司机的任务调度，只要在15分钟内没有司机接单，那么就必须一直查找附近适合的司机，直到15分钟内有司机接单为止。**任务调度搜索到满足条件的司机后，会在服务器端给**司机建立一个临时队列（1分钟过期），把新订单数据放入队列，司机小程序端开启接单服务后，每隔几秒轮询获取临时队列里面的新订单数据，在小程序前端进行语音播报，司机即可进行抢单操作。**

### 6.7任务调度——思路框架理顺

#### 1.集成xxl-job框架

**操作service-dispatch模块引入maven依赖**——项目nacos配置中心里面配置进行修改（**调度中心地址，执行器的appname,端口号ip这些。**）——创建XXL-JOB配置类（获取执行器对象）——编写任务job方法——启动两个服务测试。

#### 2.思路理顺

1.任务有一个**bean模式**的选择，我们后端代码里面会**创建一个配置类**，首先通过**value("${}")引入nacos配置中心中的配置文件**，后面创建了Spring中的执行器对象，加上@bean注解，返回值成为bean对象（Spring中的执行器）。在方法中**创建Spring执行器对象，给它读取上面的字段值，最后返回Spring执行器对象**——有了这个所以可以**检索job类中的XxlJob注释**

2.job类文件，**类上写明component**。**方法注明@XxlJob("任务名字/jobHandler")**

3**.调度中心和执行任务一般是在两个微服务模块里面。**在XXL-Job中，即使在应用配置中已添加了`XxlJobSpringExecutor`，我们仍然需要在调度中心的Web界面中手动创建一个执行器实例。这是因为XXL-Job的设计中，**执行器和调度中心之间的关联是通过“执行器名称”来完成的，调度中心本身不会主动发现新的执行器实例。**

4.我在做的项目里面引入了xxl-job-master,然后再docker的mysql使用提供的sql创建了xxl-job相关的数据库和表结构来记录操作信息。（**因为必须使用调度中心界面，它又是单独的微服务模块。登录进去用户信息的操作信息要保存所以要创建mysql**）

5.明确调度中心启动前端界面，**我们选择任务的增删改是要有后端逻辑配合的**，就在它的调度中心的源码文件夹中有增删改启动的，**我们想实现自定义功能只需要仿照改写**

总结：**所以在调度中心创建执行器和任务要确保执行器appname和任务的名字与后端配置文件里面的appname和XxlJob注解后面的任务名字一致！！！！**

### 6.8封装Xxl-job客户端

为什么要搞客户端：xxl-job调度中心要通过代码来对任务操作，提供了api接口，我只需要创建一个客户端。利用resttemplate提供的方法操作就是达到任务操作。（**因为图形化界面无法设置乘客下单后执行**）

![image-20241113145613067](.\assets\image-20241113145613067.png)

#### 1.调度中心创建任务方法xxl-job-admin

#### 2.service-dispatch配置文件添加任务方法url

#### 3.service-dispatch创建配置类，**读取**配置文件里面调用的**调度中心任务操作的方法**api

#### 4.创建客户端类，编写调用调度中心里面的方法



**总结：**调度中心底层添加任务调用的几个接口（通过调用这几个api可以完成相关操作）——.service-dispatch配置文件nancos保存调用api——.service-dispatch创建配置类读取api——最后编写客户端类，先封装好实体类需要闯入过去的，在发起http请求（调用了api路径），最后获得true/fasle或者是任务的id.达到任务添加删除更新启动效果



### 6.9 创建并启动任务接口

在service-dispatch操作，创建好乘客下单后出发任务调度的接口，在service层调用xxl-job客户端的方法，闯入相应参数。返回任务id.

![image-20241113150844957](.\assets\image-20241113150844957.png)

#### 1.创建任务启动接口

controller层和service层，在service层里面执行 xxlJobClient.addAndStart("newOrderTaskHandler", "",
                    "0 0/1 * * * ?",
                    "新创建订单任务调度：" + newOrderTaskVo.getOrderId());	

#### 2.开发具体job任务方法

jobhandler层主要是joblog日志的记录，在里面 newOrderService.executeTask(XxlJobHelper.getJobId());

executeTask方法在service层里面开发（jobid查询数据库看任务有无，查看订单状态，获取满足条件司机集合，便利集合确保一个订单只给一次司机，最后用临时队列保存每个司机的订单信息）

#### 3.乘客下单的service层加入远程调用任务调度

在保存订单信息的service层下面加入远程调用addAndStartTask



### 6.10 司机获取最新订单数据

查询最新订单和清空司机队列数据，在NewOrderController编写。**相当于之前的保存的订单临时队列在这里被调用检查。**

## 7.乘客下单大总结

![乘客下单 ](.\assets\乘客下单 .jpg)

**这里看不清，可以右键打开图片所在位置，点击就可以缩放来查看**























































