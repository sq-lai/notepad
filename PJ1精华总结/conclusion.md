# 一、Spring Cloud 微服务项目架构剖析——daijia

## 1. daijia-parent（父项目）
- **作用**：这是整个项目的父级 Maven 项目，所有子模块（如 `web`、`service` 等）都会继承这个父项目的依赖和配置。这有助于**统一管理项目中所有模块的依赖版本、插件配置，并简化各个子模块的配置。**
- **pom.xml**：`pom.xml` 文件中会**定义全局的依赖、插件配置**等，同时还会定义各个子模块。这使得所有子模块可以共享相同的配置，保持模块间的一致性。

---

## 2. common（公共模块）
- **作用**：用于存放项目中所有模块可能都会使用的**公共类和工具类**。它的作用是**减少重复代码，提升代码的复用性和一致性。**任何模块都可以引入 `common` 模块，从而使用里面的通用功能。
- **典型内容**：
  - **工具类**：如日期处理工具、字符串工具等。
  - **异常处理**：**全局异常处理类**，封装了统一的异常处理逻辑。
  - **统一响应类**：封装了 API 返回的结果对象，**如 `Result` 类，用于封装响应状态码、消息和数据。**

---

## 3. model（数据模型模块）
- **作用**：这是用于定义整个项目中使用的数据模型的模块。该模块的作用是**将数据对象进行标准化，以便在服务之间进行数据传输或持久化时保持一致。**
- **典型内容**：
  - **实体类（Entities）**：**对应数据库表的对象**，用于持久化数据。
  - **数据传输对象（DTO）**：用于**服务之间的数据传输**，通常包含 API 接口的数据字段。
  - **视图对象（VO）**：用于**前端展示的数据模型**，通常是 API 响应的数据格式。

---

## 4. server-gateway（网关服务模块）
- **作用**：作为整个微服务架构的 API 网关，**负责处理所有外部请求的统一入口**。它会将请求路由到具体的微服务，并可以实现一些预处理、后处理逻辑，如鉴权、限流、负载均衡等。**API 网关有效地将内部服务与外部隔离，使得微服务系统更安全和可控。**
- **典型技术**：Spring Cloud Gateway 或 Zuul
- **典型功能**：
  - **路由**：将**外部请求分发**到具体的微服务（如 `service`）。
  - **过滤器**：可以执行请求的预处理和后处理逻辑，例如鉴权、日志记录、限流等。
  - **负载均衡**：支持**多个服务实例之间的负载均衡。**

---

## 5. service（业务服务模块）
- **作用**：这是核心业务处理模块，**每个 `service` 模块代表一个独立的业务微服务**。每微服务负责特定的业务功能，如用户管理、订单处理等。业务逻辑、数据库交互以及和其他微服务的交互都在这个模块中实现。
- **典型内容**：
  - **业务逻辑**：具体的业务逻辑处理类和方法。
  - **控制器（Controller）**：暴露 API 接口，接收外部请求并调用业务逻辑层。
  - **数据访问层（DAO/Repository）**：与数据库交互的类，使用 JPA 或 MyBatis 访问数据库。
  - **服务层（Service）**：封装业务逻辑，并调用 DAO 层进行数据操作。

---

## 6. service-client（服务调用客户端模块）
- **作用**：这个模块是**微服务之间通信的核心部分**，它封装了与其他微服务的远程调用逻辑。通过 `service-client`，微服务之间可以通过 **HTTP 调用**进行数据交换。通常使用 **OpenFeign 或 RestTemplate** 进行服务之间的远程调用，并且可以加入负载均衡、熔断等机制，保证服务调用的稳定性。
- **典型技术**：OpenFeign、RestTemplate
- **典型功能**：
  - **远程调用**：使用 **OpenFeign 进行声明式的 HTTP 远程调用**，简化了接口调用的复杂性。
  - **负载均衡**：通过 Ribbon 或 Spring Cloud LoadBalancer 实现客户端负载均衡。
  - **熔断器**：结合 Hystrix 或 Resilience4j 实现熔断机制，保证当某个微服务不可用时，系统可以快速返回默认响应，防止故障蔓延。

---

## 7. web（Web 前端模块）
- **作用**：该模块负责**处理来自前端的 Web 请求，**充当用户接口层。**它通常会通过 API 调用后端服务（通过 `service-client` 模块调用远程服务），并将返回的数据传递给前端。**`web` 模块中的控制器类会处理具体的 HTTP 请求，调用业务逻辑，并返回相应的结果给用户。
- **典型功能**：
  - **API 控制器**：处理前端的 HTTP 请求，并调用业务服务。
  - **服务调用**：通过 `service-client` 调用后端业务服务（`service` 模块）。
  - **响应处理**：将业务逻辑处理后的结果以统一格式返回给前端。

---

## 8. 资料（Documentation）
- **作用**：存放项目相关的文档文件。可能包含项目的设计文档、接口文档、开发规范、架构图等。
- **内容**：
  - 项目设计文档
  - API 接口文档
  - 系统架构文档

---

## 项目模块的联系与典型工作流程

1. **用户请求流程**：
   - 用户通过浏览器或移动端发出请求，首先通过 **server-gateway（API 网关模块）**。
   - API 网关模块会将请求路由到 **web 模块** 中的 API 控制器。

2. **业务处理流程**：
   - **web 模块** 接收请求后，通过 `service-client` 远程调用其他业务微服务（`service` 模块）。
   - **service-client** 封装了远程调用的逻辑，可以使用 OpenFeign 或 RestTemplate 进行远程服务的通信。

3. **返回结果**：
   - **service 模块** 处理具体的业务逻辑后，返回数据给 **web 模块**。
   - **web 模块** 将数据以 API 响应的形式返回给用户。

4. **公共模块的使用**：
   - 所有模块都可以使用 **common 模块** 中的工具类、全局异常处理和其他公共逻辑。
   - 数据模型由 **model 模块** 进行定义，并在所有服务间共享。

---

# 微服务架构中的关键问题剖析

## 1. 为什么要先经过 Gateway 模块，而不是直接到 Web 模块？

### API 网关的作用
- **集中管理请求**：API 网关是整个微服务架构的**统一入口**，所有外部的请求都需要先经过 API 网关。网关会根据请求的路径或其他条件将请求路由到对应的微服务。它主要有以下功能：
  - **请求路由**：根据请求路径，将请求转发到具体的微服务，如 Web 模块或其他业务模块。
  - **安全性**：API 网关可以处理**认证和授权**，例如通过 JWT Token 进行身份验证。这样每个微服务不必各自实现复杂的安全机制，只需专注于业务逻辑。
  - **负载均衡**：API 网关可以对请求进行**负载均衡**，将流量均匀分配到不同的服务实例中，避免某些实例的过载。
  - **统一入口**：API 网关为所有微服务提供了一个统一的外部访问入口，客户端只需要知道网关的地址，不必了解具体的微服务位置。
  - **跨域处理**：如果前端与后端进行跨域请求，API 网关可以统一处理跨域请求，简化微服务中的跨域管理。

### 为什么不能直接跳过网关？
- **缺少统一管理**：如果每个外部请求都直接访问具体的微服务（如 Web 模块或业务模块），系统将失去统一管理请求、安全控制和流量管理的能力。这会导致安全隐患和管理的复杂性增加。
- **负载均衡问题**：直接访问服务可能会导致某些服务实例过载，无法有效分配请求压力。网关的负载均衡功能可以确保请求均衡分布，提高系统的稳定性。

### API 网关的关键功能：
- **路由**：将请求分发到后端的具体服务。
- **鉴权与安全**：处理身份认证和权限校验。
- **负载均衡**：均匀分配请求。
- **流量控制**：限流、防止请求泛滥。
- **跨域支持**：统一处理跨域请求。

---

## 2. 为什么要加 Web 模块，业务模块里面的 Controller 层不能直接返回数据给前端？

### Web 模块的作用
- **分层架构的设计**：Web 模块通常用于处理用户接口请求，是整个系统的“表现层”。虽然业务模块中的 `Controller` 层也能直接处理外部请求，但将 Web 层和业务层分开有以下好处：
  - **职责分离**：Web 模块专注于处理**前端请求和展示逻辑**，而业务模块专注于处理**核心业务逻辑**。这种设计可以让系统的关注点更加明确，便于维护和扩展。
  - **适配前端需求**：Web 模块可以对前端的请求和返回数据格式进行定制，帮助不同类型的客户端（Web、移动端）处理不同的数据需求。例如，Web 模块可以将后端返回的数据封装成符合前端需求的格式，并对接口进行适配。
  - **安全和前端适配逻辑**：Web 模块还可以负责一些前端适配逻辑（如分页、过滤、数据格式转换），减少对业务模块的侵入。
  - **可扩展性**：Web 模块的独立性使得未来如果需要更改前端需求或增加更多接口逻辑，可以仅修改 Web 模块而不需要改变核心的业务模块，增强系统的扩展性和灵活性。

### 为什么业务模块不直接返回数据给前端？
- **避免职责混乱**：业务模块中的 `Controller` 层主要用于处理核心业务逻辑，如果让它同时处理前端请求、适配前端需求，这会导致职责混乱，降低代码的可读性和可维护性。
- **前后端分离的设计理念**：前后端分离是现代 Web 开发的趋势，Web 模块可以作为 API 层来处理前端请求，而业务模块仅专注于业务逻辑。这样设计有助于实现系统的高内聚低耦合。

### Web 模块的关键功能：
- **处理外部请求**：处理用户的 HTTP 请求。
- **数据格式转换**：将后端的数据处理成前端需要的格式（如 JSON）。
- **前端适配**：根据不同客户端需求，定制接口响应。

---

## 3. 为什么 Web 模块要通过 service-client 使用业务逻辑模块？什么是 OpenFeign 和 RestTemplate？

### 为什么 Web 模块要通过 `service-client` 访问业务模块？
- **服务解耦**：在微服务架构中，业务模块和 Web 模块通常是**独立的微服务**。它们之间的通信通常通过 **HTTP 远程调用**进行，而不是直接调用类或方法。**`service-client` 模块封装了这些远程调用的逻辑**，使 Web 模块不需要知道业务模块的实现细节，只**需要调用服务的接口。**这种方式有助于服务解耦，便于系统扩展和维护。
  - **松耦合架构**：通过 `service-client` 进行远程调用，Web 模块不需要直接依赖业务模块的实现，可以专注于前端逻辑。
  - **高扩展性**：当业务模块需要更新或扩展时，只需要修改 `service-client` 的调用逻辑，而不必修改 Web 模块的代码。
  - **网络通信的封装**：`service-client` **可以封装网络通信的细节，如服务发现、负载均衡等。**

### 什么是 OpenFeign 和 RestTemplate？
- **OpenFeign**：是 Spring Cloud 中的一个**声明式 HTTP 客户端**，它使得开发者可以用类似调用本地方法的方式**进行远程服务调用，而不需要手动编写 HTTP 请求。**
  
  - **简单声明式调用**：通过**定义接口并使用注解，Feign 可以自动处理 HTTP 请求和响应**，开发者不需要关心底层细节。
  - **负载均衡支持**：Feign 可以集成 Ribbon，实现客户端的负载均衡。
  - **熔断器支持**：与 Hystrix 或 Resilience4j 结合，可以实现远程调用失败时的熔断机制。
  - **示例**：
    ```java
    @FeignClient("user-service")
    public interface UserServiceClient {
        @GetMapping("/api/users/{id}")
        UserDTO getUserById(@PathVariable("id") Long id);
    }
    ```
  
- **RestTemplate**：是 Spring 提供的用于**同步 HTTP 请求**的工具类，它支持基本的 HTTP 请求操作（如 GET、POST、PUT、DELETE）。相对于 Feign，RestTemplate 更底层，需要手动编写 HTTP 请求和处理响应。
  - **灵活性高**：可以自定义请求和响应，适合复杂的场景。
  - **手动处理请求**：开发者需要手动构造请求 URL、请求体等，适合自定义需求较高的场景。
  - **示例**：
    ```java
    RestTemplate restTemplate = new RestTemplate();
    ResponseEntity<UserDTO> response = restTemplate.getForEntity("http://user-service/api/users/{id}", UserDTO.class, id);
    ```

### OpenFeign 与 RestTemplate 的选择
- **OpenFeign** 更适合场景：对于大多数**简单的远程调用**场景，使用 OpenFeign 更加简洁和易维护，因为它提供了声明式的调用方式，减少了手动构造 HTTP 请求的工作。（Rest API用这个）
- **RestTemplate** 更适合场景：当需要更多的自定义控制（如定制 HTTP 请求头、处理复杂的请求/响应结构）时，**RestTemplate** 可能更合适，因为它提供了更灵活的控制。

### `service-client` 的作用：
- **封装远程调用**：通过 OpenFeign 或 RestTemplate 封装对其他微服务的调用逻辑，简化 Web 模块的工作。
- **负载均衡和熔断支持**：提供客户端负载均衡和熔断机制，提升系统的稳定性。

---

## 总结

1. **为什么要经过 Gateway（就是API网关） 模块？**
   - API 网关提供了**请求路由、负载均衡、安全认证、流量控制**等功能，是微服务架构中的统一入口。跳过网关将导致请求管理的复杂性增加，并且无法集中处理安全和负载均衡等问题。
2. **为什么要加 Web 模块？**
   - Web 模块专注于处理外部请求并适配前端需求，业务模块专注于核心业务逻辑。将二者分离有助于系统的职责分离，提高可维护性和扩展性。**微服务架构关键：解耦！！！**
3. **为什么 Web 模块要通过 `service-client` 使用业务模块？**
   - 在微服务架构中，业务模块与 Web 模块是独立的服务，`service-client` 封装了远程服务调用逻辑，使微服务之间的调用更加简单！！！

------



# 项目模块拆分——从前到后

## 1.项目概述（项目介绍、框架图）

### 1.1技术架构

![](.\assets\image-20240620203904041.png)

### 1.2 技术概述

- **SpringBoot**：简化Spring应用的初始搭建以及开发过程
- **SpringCloud**：基于Spring Boot实现的云原生应用开发工具，SpringCloud使用的技术：（Spring Cloud Gateway、Spring Cloud Task和Spring Cloud Feign等）
- **SpringBoot+SpringCloudAlibaba(Nacos，Sentinel) + OpenFeign + Gateway**
- MyBatis-Plus：持久层框架，也依赖mybatis
- Redis：内存做缓存
- Redisson：基于redis的Java驻内存数据网格 - 框架；操作redis的框架
- MongoDB: 分布式文件存储的数据库
- RabbitMQ：消息中间件；大型分布式项目是标配；分布式事务最终一致性
- Seata：分布式事务
- Drools：规则引擎，计算预估费用、取消费用等等
- GEO：GPS分区定位计算
- ThreadPoolExecutor+CompletableFuture：异步编排，线程池来实现异步操作，提高效率
- XXL-JOB: 分布式定时任务调用中心
- Knife4J/YAPI：Api接口文档工具
- MinIO（私有化对象存储集群）：分布式文件存储 类似于OSS（公有）
- 微信支付：微信支付与微信分账
- MySQL：关系型数据库 {shardingSphere-jdbc 进行读写分离; 分库，分表}
- Lombok: 实体类的中get/set 生成的jar包
- Natapp：内网穿透
- Docker：容器化技术;  生产环境Redis（运维人员）；快速搭建环境Docker run

### 1.3 业务流程

![](.\assets\image-20240620210153207.png)

![](.\assets\image-20240620210245930.png)

![](.\assets\image-20240620210300386.png)

## 2.乘客端登录

### 2.1微信小程序登录接口开发

![](.\assets\image-20240506112804142.png)

![](.\assets\image-20241024224319373.png)

### 2.2获取登录用户信息接口开发

![](.\assets\image-20240507094816943.png)

### 2.3 登录校验

-- 判断请求头里面是否包含token字符串

-- 根据token查询redis

-- 原始方式：在需要判断登录的controller进行上面判断（token和redis）

-- 如果使用原始方式，功能肯定可以实现的，但是造成有大量重复代码

-- 对这样方式进行优化

![](.\assets\image-20240507135812851.png)

![](.\assets\image-20240507140803142.png)

![](.\assets\image-20240507140821251.png)

创建自定义注解要加上元注解（**元注解就是对注解的说明限制**）；@interface是注解的意思，不是接口！！！！



### 2.4 乘客端登录：获取微信手机号

**说明：获取手机号必须是企业级微信公众号，个人版获取不到。**

如果登录发现没有绑定手机号，那么返回的那个实体类手机号字段为fasle，**触发前端页面显示要绑定手机号（此时前端会请求一个资源路径）** 用户同意一键绑定手机号，会获得动态令牌code，通过code获取手机号。**注意：每个code只能使用一次，code的有效期为5min。**

重点：**用户点击一键绑定会调用接口自动获取code，并把code和用户id以json文件形式发到后端！！！**

![](.\assets\image-20240507214147107.png)



## 3.司机端登录与认证

![](.\assets\image-20240510135339274.png)

































